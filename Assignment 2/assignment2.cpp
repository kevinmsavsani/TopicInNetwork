
#include <iomanip>
#include <bits/stdc++.h>
using namespace std;

int N = 8;		// Number of switch input and output ports
int B = 4;		// Buffer size
double p = 0.5;	// Packet generation probability
int T = 10000;	// simulation time
double K = 0.6 * N;	// maximum packet that can arrive in a slot for a particular output port

std::vector<int> delay;	// stores sum packet delay for all output port
vector<double> output_avg_sd;
string outfile;	// output file name

void calculate_mean_sd()
{
	double sum=0;
	double mean;
	double sd=0;
	double n=delay.size();


	for(int i=0;i<n;i++)
	{
		sum+=delay[i];
	}

	mean=sum/n;

	output_avg_sd.push_back(mean);

	for(int i=0;i<n;i++)
	{
		sd+=pow(delay[i]-mean,2);
	}



	sd=sqrt(sd/n);

	output_avg_sd.push_back(sd);


}



// function for INQ queue scheduling technique
void INQ()
{
    ofstream myfile;
  	myfile.open (outfile+".txt",ios::app);

	vector<vector<pair<int,int>>> inputbuffer( N );		// packet generated are stored in this buffer till they are scheduled
    vector<vector<pair<int,int>>> scheduled( N );		// packet scheduled are stored in this till they are transmitted to outputbuffer
    vector<vector<pair<int,int>>> outputbuffer( N );	// packet are stored in this buffer for each output port

    vector<int> outputNum;	// It stores all output number present in start of inputbuffer which can be transmitted to outputbuffer
	double link_u=0;	// stores number of links utilised

	// Each i represent a time slot
	for (int i = 0; i < T; ++i)
	{
		for (int j = 0; j < N; ++j)	// for all output port
		{
			if (outputbuffer[j].size() > 0)	// if packet exist at output port j
			{
				int curr_delay=i - outputbuffer[j][0].first;	// get time packet spent in transmission
				delay.push_back(curr_delay);	// stores all delays
				link_u++;	// one link utilised here

			    outputbuffer[j].clear();	// removes packet which finishes transmission 
			}				 				
		}

		// for packet transmission
		for (int j = 0; j < N; ++j)	// for all output port
		{
			if (scheduled[j].size() > 0)	// if packet exist for output port j
			{
				outputbuffer[j].push_back(make_pair(scheduled[j][0].first, scheduled[j][0].second));	// passes from scheduled to outputbuffer
			    scheduled[j].clear();	// removes packet which is transmitted 
			}				 				
		}
	
		// for packet scheduling
		for (int j = 0; j < N; ++j)	// for all output port
		{
			outputNum.clear();
			for (int k = 0; k < N; ++k)	// for all input port 
			{
				if(inputbuffer[k].size() > 0 && inputbuffer[k][0].second == j){
					outputNum.push_back(k);	// get all input port which has first packet to be transmitted to j output port
				}
			}

			if (outputNum.size() > 0) // check if output exist to port j
			{
				    int range_from  = 0;
					int range_to    = outputNum.size()-1;
					std::random_device                  rand_dev;  //Will be used to obtain a seed for the random number engine
					std::mt19937                        generator(rand_dev());  //Standard mersenne_twister_engine seeded with rand_dev()
					std::uniform_int_distribution<int>  distr(range_from, range_to);   
					int num = distr(generator);

					vector<pair<int,int>>::iterator it; 

				    it = inputbuffer[outputNum[num]].begin(); 
				    scheduled[inputbuffer[outputNum[num]][0].second].push_back(make_pair(inputbuffer[outputNum[num]][0].first, outputNum[num]));	// passes from inputbuffer to scheduled 
				    inputbuffer[outputNum[num]].erase(it); 	// removes packet from input buffer
			}
			outputNum.clear();
		}

		// for generating packet
		for (int j = 0; j < N; ++j)	// for all input port  
		{
			const int range_from  = 0;
			const int range_to    = 999;
			std::random_device                  rand_dev;  //Will be used to obtain a seed for the random number engine
			std::mt19937                        generator(rand_dev());  //Standard mersenne_twister_engine seeded with rand_dev()
			std::uniform_int_distribution<int>  distr(range_from, range_to);   

			if(distr(generator) < range_to*p && inputbuffer[j].size() < B) {
				const int range_from  = 0;
				const int range_to    = N-1;
				std::random_device                  r_d;  //Will be used to obtain a seed for the random number engine
				std::mt19937                        gen(r_d());  //Standard mersenne_twister_engine seeded with rand_dev()
				std::uniform_int_distribution<int>  dis(range_from, range_to);    

				// Use dis to transform the random unsigned int generated by gen into an int in [range_from, range_to]
				inputbuffer[j].push_back( make_pair(i,dis(gen)));     
			}
		}
	}


	calculate_mean_sd();
	link_u=link_u/(T*N);

	cout<<"N"<<"\t\t"<<"p"<<"\t\t"<<"Queue Type"<<"\t"<<"Average PD"<<"\t"<<"Std Dev of PD"<<"\t"<<"Average Link Utilisation"<<endl;
	cout<<N<<"\t\t"<<p<<"\t\t"<<"INQ "<<"\t\t"<<fixed<<setprecision(5)<<output_avg_sd[0]<<"\t\t"<<fixed<<setprecision(5)<<output_avg_sd[1]<<"\t\t\t"<<fixed<<setprecision(5)<<link_u<<endl;

	myfile<<N<<"\t\t"<<p<<"\t\t"<<"INQ "<<"\t\t"<<fixed<<setprecision(5)<<output_avg_sd[0]<<"\t\t"<<fixed<<setprecision(5)<<output_avg_sd[1]<<"\t\t\t"<<fixed<<setprecision(5)<<link_u<<endl;	

	myfile.close();
}

// function for KOUQ queue scheduling technique
void KOUQ(){

    ofstream myfile;
  	myfile.open (outfile+".txt",ios::app);

	vector<vector<pair<int,int>>> inputbuffer( N );		// packet generated are stored in this buffer till they are scheduled
    vector<vector<pair<int,int>>> scheduled( N );		// packet scheduled are stored in this till they are transmitted to outputbuffer
    vector<vector<pair<int,int>>> outputbuffer( N );	// packet are stored in this buffer for each output port

    vector<pair<int,int>> inputNumber;	// stores input port with its probability of being scheduled

	double link_u=0;	// stores number of links utilised
    double KOUQ_drop_prob=0;

	// Each i represent a time slot
	for (int i = 0; i < T; ++i)
	{
		for (int j = 0; j < N; ++j)	// for all output port
		{
			if (outputbuffer[j].size() > 0)	// if packet exist at output port j
			{
				int curr_delay=i - outputbuffer[j][0].first;	// get time packet spent in transmission
				delay.push_back(curr_delay);	// stores all delays
				link_u++;	// one link utilised here

			    vector<pair<int,int>>::iterator it; 

			    it = outputbuffer[j].begin(); 
			    outputbuffer[j].erase(it);	// removes packet which finishes transmission 
			}
		}

		// for packet transmission
		for (int j = 0; j < N; ++j)	// for all output port
		{
			if (scheduled[j].size() > 0)	// if packet exist for output port j
			{
				for (int k = 0; k < scheduled[j].size(); ++k)
				{
					outputbuffer[j].push_back(make_pair(scheduled[j][k].first, scheduled[j][k].second));	// passes from scheduled to outputbuffer
				}
			    scheduled[j].clear();
			}				 				
		}


		// for scheduling we gave each input port a number uniformly and we sorted it and smaller the number higher is the probability to be scheduled is used here.
		sort(inputNumber.begin(),inputNumber.end());

		vector<int> numOut(N,0);	// for each output port count number of packet to be transmitted to it in a time slot

		for (int j = 0; j < inputNumber.size(); ++j)
		{
			numOut[inputbuffer[inputNumber[j].second][0].second]++;
			// checks that number of packet to an output port cannot be greater than K in a given time stamp
			if (numOut[inputbuffer[inputNumber[j].second][0].second]<K && (outputbuffer[inputbuffer[inputNumber[j].second][0].second].size()+scheduled[inputbuffer[inputNumber[j].second][0].second].size())<B)
			{
				//// passes from inputbuffer to scheduled and remove from input buffer
				scheduled[inputbuffer[inputNumber[j].second][0].second].push_back(make_pair(inputbuffer[inputNumber[j].second][0].first, inputbuffer[inputNumber[j].second][0].second));
				inputbuffer[inputNumber[j].second].clear();
			}				
		}
		inputNumber.clear();

		for(int k=0;k<numOut.size();k++)
		{
			if(numOut[k]>K)
				KOUQ_drop_prob++;
		}

		// for packet generation
		for (int j = 0; j < N; ++j) // for each input port
		{
			const int range_from  = 0;
			const int range_to    = 10000;
			std::random_device                  r_d;  //Will be used to obtain a seed for the random number engine
			std::mt19937                        gen(r_d());  //Standard mersenne_twister_engine seeded with rand_dev()
			std::uniform_int_distribution<int>  dis(range_from, range_to);   

			if(dis(gen) < range_to*p) {
				const int range_from  = 0;
				const int range_to    = N-1;
				std::random_device                  rand_dev;  //Will be used to obtain a seed for the random number engine
				std::mt19937                        generator(rand_dev());  //Standard mersenne_twister_engine seeded with rand_dev()
				std::uniform_int_distribution<int>  distr(range_from, range_to);   
				inputbuffer[j].push_back( make_pair(i,distr(generator))); 
				inputNumber.push_back( make_pair(dis(gen),j));     //Use dis to transform the random unsigned int generated by gen into an int in [range_from, range_to]
			}								
		}
	}

	KOUQ_drop_prob=(KOUQ_drop_prob/N)/T;

	calculate_mean_sd();
	link_u=link_u/(T*N);

	cout<<"N"<<"\t\t"<<"p"<<"\t\t"<<"Queue Type"<<"\t"<<"Average PD"<<"\t"<<"Std Dev of PD"<<"\t"<<"Average Link Utilisation"<<"\t"<<"KOUQ Drop Probability"<<endl;
	cout<<N<<"\t\t"<<p<<"\t\t"<<"KOUQ"<<"\t\t"<<fixed<<setprecision(5)<<output_avg_sd[0]<<"\t\t"<<fixed<<setprecision(5)<<output_avg_sd[1]<<"\t\t\t"<<fixed<<setprecision(5)<<link_u<<"\t\t\t\t"<<KOUQ_drop_prob<<endl;

	myfile<<N<<"\t\t"<<p<<"\t\t"<<"KOUQ"<<"\t\t"<<fixed<<setprecision(5)<<output_avg_sd[0]<<"\t\t"<<fixed<<setprecision(5)<<output_avg_sd[1]<<"\t\t\t"<<fixed<<setprecision(5)<<link_u<<"\t\t\t\t"<<KOUQ_drop_prob<<endl;
	myfile.close();

}

// function for iSLIP queue scheduling technique
void iSLIP(){

    ofstream myfile;
  	myfile.open (outfile+".txt",ios::app);

	double link_u=0;	// stores number of links utilised

	vector<vector<pair<int,int>>> inputbuffer( N );		// packet generated are stored in this buffer till they are scheduled
    vector<vector<pair<int,int>>> scheduled( N );		// packet scheduled are stored in this till they are transmitted to outputbuffer
    vector<vector<pair<int,int>>> outputbuffer( N );	// packet are stored in this buffer for each output port

    vector<int> inputNum;

	// Each i represent a time slot
	for (int i = 0; i < T; ++i)
	{
		for (int j = 0; j < N; ++j)	// for all output port
		{
			if (outputbuffer[j].size() > 0)	// if packet exist at output port j
			{
				int curr_delay=i - outputbuffer[j][0].first;	// get time packet spent in transmission
				delay.push_back(curr_delay);	// stores all delays
				link_u++;	// one link utilised here

			    outputbuffer[j].clear();	// removes packet which finishes transmission 
			}				 				
		}

		// for packet transmission
		for (int j = 0; j < N; ++j)	// for all output port
		{
			if (scheduled[j].size() > 0)	// if packet exist for output port j
			{
				outputbuffer[j].push_back(make_pair(scheduled[j][0].first, scheduled[j][0].second));	// passes from scheduled to outputbuffer
			    scheduled[j].clear();	// removes packet which is transmitted 
			}				 				
		}
		
		vector<int> grantPhase(N);	// stores output of grant phase
    	vector<int> acceptPhase(N);	// stores output of accept phase
		vector<vector<pair<int,int>>> requestPhase( N );	// stores input for request phase

		requestPhase = inputbuffer;	// initialise requestphase with inputbuffer

		acceptPhase.assign(N,-1);

		// run till complete scheduling is done
		while (true)
		{
			grantPhase.assign(N,-1);
			int addNum = 0;	// selection in grant phase of input port is round robin so addNum store previous number

			// grant phase output is generated from request phase
			for (int j = 0; j < N; ++j)   // j for output port
			{
				for (int k = 0; k < N; ++k)   // k for input port
				{
					// check if output port j is already granted
					if (grantPhase[j]!= -1)
					{
						break;
					}
					if (requestPhase[(addNum +k )% N].size() > 0)	 
					{
						for(int l= 0;l <requestPhase[(addNum +k )% N].size();l++){
							// checks if input port (addNum+k)%N has packet for output port j
							if (requestPhase[(addNum +k )% N][l].second == j)
							{
								grantPhase[j] = (addNum +k )% N;
								addNum = grantPhase[j]+1; // stores round robin start value for next iteration
								break;
							}
						}
					}
					
				}
			}

			// accept phase output is generated from grant phase
			// request phase for next iteration is updated
			for (int j = 0; j < N; ++j)   // j for input port
			{
				for (int k = 0; k < N; ++k)   // k for output port
				{
					// check if input port j is already accepted				
					if (acceptPhase[j] != -1)
					{
						break;
					}
					// check if output port k is granted to input port j
					if (grantPhase[k] == j)
					{
						acceptPhase[j] = k;

						requestPhase[j].clear(); // input port j is cleared for next iteration in request phase

						vector<pair<int,int>>::iterator it; 

						for (int q = 0; q < N; ++q)   // q for input port
						{
							if (requestPhase[q].size() > 0)
							{
								for(int l= 0;l <requestPhase[q].size();l++){
									if (requestPhase[q][l].second == k)
									{
										it = requestPhase[q].begin() + l; 
					    				requestPhase[q].erase(it);	// removes output port k from every input for next iteration in request phase
									}
								}
							}
							
						}

						if (inputbuffer[j].size() > 0)
						{
							for(int l= 0;l <inputbuffer[j].size();l++){
								if (inputbuffer[j][l].second == k)
								{
									scheduled[k].push_back( make_pair(inputbuffer[j][l].first,j));
									it = inputbuffer[j].begin() + l; 
				    				inputbuffer[j].erase(it); // removes output port k from inputbuffer as it is accepted
									break;
								}
							}
						}
					}
				}
				
			}

			// it check if all input port of request phase are empty or not. if empty then scheduling is completed
			int r = 0;			
			for (r = 0; r < N; ++r)
			{
				if (requestPhase[r].size() > 0)
				{
					break;
				}
			}
			if (r == N)
			{
				break;
			}
		}
	

		// for packet generation
		for (int j = 0; j < N; ++j) // for each input port
		{
			const int range_from  = 0;
			const int range_to    = 999;
			std::random_device                  rand_dev;  //Will be used to obtain a seed for the random number engine
			std::mt19937                        generator(rand_dev());  //Standard mersenne_twister_engine seeded with rand_dev()
			std::uniform_int_distribution<int>  distr(range_from, range_to);   

			if(distr(generator) < range_to*p && inputbuffer[j].size() < B) {
				const int range_from  = 0;
				const int range_to    = N-1;
				std::random_device                  r_d;  //Will be used to obtain a seed for the random number engine
				std::mt19937                        gen(r_d());  //Standard mersenne_twister_engine seeded with rand_dev()
				std::uniform_int_distribution<int>  dis(range_from, range_to);    

				inputbuffer[j].push_back( make_pair(i,dis(gen)));     //Use dis to transform the random unsigned int generated by gen into an int in [range_from, range_to]
			}
		}
		
	}


	calculate_mean_sd();
	link_u=link_u/(T*N);

	cout<<"N"<<"\t\t"<<"p"<<"\t\t"<<"Queue Type"<<"\t"<<"Average PD"<<"\t"<<"Std Dev of PD"<<"\t"<<"Average Link Utilisation"<<endl;
	cout<<N<<"\t\t"<<p<<"\t\t"<<"iSLIP"<<"\t\t"<<fixed<<setprecision(5)<<output_avg_sd[0]<<"\t\t"<<fixed<<setprecision(5)<<output_avg_sd[1]<<"\t\t\t"<<fixed<<setprecision(5)<<link_u<<endl;

	myfile<<N<<"\t\t"<<p<<"\t\t"<<"iSLIP"<<"\t\t"<<fixed<<setprecision(5)<<output_avg_sd[0]<<"\t\t"<<fixed<<setprecision(5)<<output_avg_sd[1]<<"\t\t\t"<<fixed<<setprecision(5)<<link_u<<endl;
	myfile.close();

}

int main(int argc, char** argv) 
{ 
	const char* queue = "INQ";
	outfile="outputfile";
    for (int i = 0; i < argc; ++i) {
    	if (strcmp("-N",argv[i])==0)
    	{
    		i++;
    		N = atoi(argv[i]);
    		K = 0.6 * N;
    	} else if (strcmp("-B",argv[i])==0)
    	{
    		i++;
    		B = atoi(argv[i]);
    	} else if (strcmp("-p",argv[i])==0)
    	{
    		i++;
    		p = atof(argv[i]);
    	} else if (strcmp("-queue",argv[i])==0)
    	{
    		i++;
    		queue = argv[i];
    	} else if (strcmp("-K",argv[i])==0)
    	{
    		i++;
    		K = atof(argv[i]);
    		K=K*N;
    	} else if (strcmp("-out",argv[i])==0)
    	{
    		i++;
    		outfile=argv[i];
    	} else if (strcmp("-T",argv[i])==0)
    	{
    		i++;
    		T = atoi(argv[i]);
    	}
    }	

    cout << endl << endl;

    if (strcmp("INQ", queue)==0)
    {
	    INQ();
	}

	if (strcmp("KOUQ", queue)==0)
    {
    	KOUQ();	    
	}

	if (strcmp("iSLIP", queue)==0)
    {
    	iSLIP();	    
	}

    return 0; 
} 

