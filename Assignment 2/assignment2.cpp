#include <bits/stdc++.h>

using namespace std;

int in;
int N = 8;
int B = 4;
double p = 0.5;
int T = 10000;
double K = 0.6 * N;
std::vector<int> delay;
vector<vector<double> > link_util(N,vector<double> (N,0)); 
vector<double> output_avg_sd;
string outfile;

void calculate_mean_sd()
{
	double sum=0;
	double mean;
	double sd=0;
	double n=delay.size();


	for(int i=0;i<n;i++)
	{
		sum+=delay[i];
	}

	mean=sum/n;

	cout<<"Average PD "<<mean<<endl;
	output_avg_sd.push_back(mean);

	for(int i=0;i<n;i++)
	{
		sd+=pow(delay[i]-mean,2);
	}



	sd=sqrt(sd/n);

	cout<<"SD of PD "<<sd<<endl;
	output_avg_sd.push_back(sd);


}


double link_utilization()
{
	int N=link_util.size();
	double sum=0;
	for(int i=0;i<N;i++)
	{
		for(int j=0;j<N;j++)
		{
			link_util[i][j]=link_util[i][j]/T;
			sum+=link_util[i][j];
		}
	}

	sum=sum/(N*N);

	cout<<" Average link_util :"<< sum<<endl;
	return sum;

}

void inq(){

    ofstream myfile;
  	myfile.open (outfile+".txt");
	vector<vector<pair<int,int>>> inputbuffer( N );
    vector<vector<pair<int,int>>> scheduled( N );
    vector<vector<pair<int,int>>> outputbuffer( N );
    vector<int> inputNum;

 
	for (int i = 0; i < T; ++i)
	{
		for (int j = 0; j < N; ++j)
		{
			if (outputbuffer[j].size() > 0)
			{
				//cout << outputbuffer[j][0].first << "  " << i << endl;
				int curr_delay=i- outputbuffer[j][0].first;
				delay.push_back(curr_delay);
				link_util[outputbuffer[j][0].second][j]++;

			    outputbuffer[j].clear();
			}				 				
		}

		for (int j = 0; j < N; ++j)
		{
			if (scheduled[j].size() > 0)
			{
				outputbuffer[j].push_back(make_pair(scheduled[j][0].first, scheduled[j][0].second));

			    scheduled[j].clear();
			}				 				
		}
	

		for (int j = 0; j < N; ++j)
		{
			inputNum.clear();
			for (int k = 0; k < N; ++k)
			{
				if(inputbuffer[k].size() > 0 && inputbuffer[k][0].second == j){
					inputNum.push_back(k);
				}
			}
			if (inputNum.size() > 0)
			{
				    int range_from  = 0;
					int range_to    = inputNum.size()-1;
					std::random_device                  rand_dev;  //Will be used to obtain a seed for the random number engine
					std::mt19937                        generator(rand_dev());  //Standard mersenne_twister_engine seeded with rand_dev()
					std::uniform_int_distribution<int>  distr(range_from, range_to);   
					int num = distr(generator);
					//cout << inputbuffer[inputNum[num]][0].first << "  " << i << endl;

					

					vector<pair<int,int>>::iterator it; 

				    it = inputbuffer[inputNum[num]].begin(); 
				    scheduled[inputbuffer[inputNum[num]][0].second].push_back(make_pair(inputbuffer[inputNum[num]][0].first, inputNum[num]));
				    inputbuffer[inputNum[num]].erase(it); 
			}
			inputNum.clear();
		}

		for (int j = 0; j < N; ++j)
		{
			const int range_from  = 0;
			const int range_to    = 999;
			std::random_device                  rand_dev;  //Will be used to obtain a seed for the random number engine
			std::mt19937                        generator(rand_dev());  //Standard mersenne_twister_engine seeded with rand_dev()
			std::uniform_int_distribution<int>  distr(range_from, range_to);   

			if(distr(generator) < range_to*p && inputbuffer[j].size() < B) {
				const int range_from  = 0;
				const int range_to    = N-1;
				std::random_device                  r_d;  //Will be used to obtain a seed for the random number engine
				std::mt19937                        gen(r_d());  //Standard mersenne_twister_engine seeded with rand_dev()
				std::uniform_int_distribution<int>  dis(range_from, range_to);    

				inputbuffer[j].push_back( make_pair(i,dis(gen)));     //Use dis to transform the random unsigned int generated by gen into an int in [range_from, range_to]
			}
		}
	}


	calculate_mean_sd();
	double output_link_util=link_utilization();

	cout<<"N"<<"\t\t"<<"p"<<"\t\t"<<"Queue Type"<<"\t"<<"Average PD"<<"\t"<<"Std Dev of PD"<<"\t"<<"Average Link Utilisation"<<endl;
	cout<<N<<"\t\t"<<p<<"\t\t"<<"INQ"<<"\t\t"<<output_avg_sd[0]<<"\t\t"<<output_avg_sd[1]<<"\t\t"<<output_link_util<<endl;

	myfile<<"N"<<"\t\t"<<"p"<<"\t\t"<<"Queue Type"<<"\t"<<"Average PD"<<"\t"<<"Std Dev of PD"<<"\t"<<"Average Link Utilisation"<<endl;
	myfile<<N<<"\t\t"<<p<<"\t\t"<<"INQ"<<"\t\t"<<output_avg_sd[0]<<"\t\t"<<output_avg_sd[1]<<"\t\t"<<output_link_util<<endl;	

	myfile.close();
}

void kouq(){

    ofstream myfile;
  	myfile.open (outfile+".txt");
	vector<vector<pair<int,int>>> inputbuffer( N );
    vector<vector<pair<int,int>>> scheduled( N );
    vector<vector<pair<int,int>>> outputbuffer(N);

    vector<pair<int,int>> inputNumber;

    double link_u=0;
    double KOUQ_drop_prob=0;

	for (int i = 0; i < T; ++i)
	{
		for (int j = 0; j < N; ++j)
		{
			if (outputbuffer[j].size() > 0)
			{
				//cout << outputbuffer[j][0].first << "  " << i << endl;

				int curr_delay= i - outputbuffer[j][0].first;
				delay.push_back(curr_delay);
				link_u++;

				vector<pair<int,int>>::iterator it; 

			    it = outputbuffer[j].begin(); 
			    outputbuffer[j].erase(it);
			}
			 
			
		}

		for (int j = 0; j < N; ++j)
		{
			if (scheduled[j].size() > 0)
			{
				for (int k = 0; k < scheduled[j].size(); ++k)
				{
					outputbuffer[j].push_back(make_pair(scheduled[j][k].first, scheduled[j][k].second));
				}

			    scheduled[j].clear();
			}				 				
		}

		sort(inputNumber.begin(),inputNumber.end());

		vector<int> numOut(N,0);

		for (int j = 0; j < inputNumber.size(); ++j)
		{
			numOut[inputbuffer[inputNumber[j].second][0].second]++;
			if (numOut[inputbuffer[inputNumber[j].second][0].second]<K && (outputbuffer[inputbuffer[inputNumber[j].second][0].second].size()+scheduled[inputbuffer[inputNumber[j].second][0].second].size())<B)
			{
				scheduled[inputbuffer[inputNumber[j].second][0].second].push_back(make_pair(inputbuffer[inputNumber[j].second][0].first, inputbuffer[inputNumber[j].second][0].second));
				inputbuffer[inputNumber[j].second].clear();
			}				
		}
		inputNumber.clear();

		for (int j = 0; j < N; ++j)
		{
			const int range_from  = 0;
			const int range_to    = 10000;
			std::random_device                  r_d;  //Will be used to obtain a seed for the random number engine
			std::mt19937                        gen(r_d());  //Standard mersenne_twister_engine seeded with rand_dev()
			std::uniform_int_distribution<int>  dis(range_from, range_to);   

			if(dis(gen) < range_to*p) {
				const int range_from  = 0;
				const int range_to    = N-1;
				std::random_device                  rand_dev;  //Will be used to obtain a seed for the random number engine
				std::mt19937                        generator(rand_dev());  //Standard mersenne_twister_engine seeded with rand_dev()
				std::uniform_int_distribution<int>  distr(range_from, range_to);   
				inputbuffer[j].push_back( make_pair(i,distr(generator))); 
				inputNumber.push_back( make_pair(dis(gen),j));     //Use dis to transform the random unsigned int generated by gen into an int in [range_from, range_to]
			}								
		}



		for(int k=0;k<numOut.size();k++)
		{
			if(numOut[k]>K)
				KOUQ_drop_prob++;
		}


	}

	KOUQ_drop_prob=(KOUQ_drop_prob/N)/T;

	calculate_mean_sd();
	link_u=(link_u/T)/(N*N);
	//cout<<"Link Util :"<<link_u<<endl;

	cout<<"N"<<"\t\t"<<"p"<<"\t\t"<<"Queue Type"<<"\t"<<"Average PD"<<"\t"<<"Std Dev of PD"<<"\t"<<"Average Link Utilisation"<<"\t"<<"KOUQ Drop Probability"<<endl;
	cout<<N<<"\t\t"<<p<<"\t\t"<<"KOUQ"<<"\t\t"<<output_avg_sd[0]<<"\t\t"<<output_avg_sd[1]<<"\t\t"<<link_u<<"\t\t"<<KOUQ_drop_prob<<endl;

	myfile<<"N"<<"\t\t"<<"p"<<"\t\t"<<"Queue Type"<<"\t"<<"Average PD"<<"\t"<<"Std Dev of PD"<<"\t"<<"Average Link Utilisation"<<"\t"<<"KOUQ Drop Probability"<<endl;
	myfile<<N<<"\t\t"<<p<<"\t\t"<<"KOUQ"<<"\t\t"<<output_avg_sd[0]<<"\t\t"<<output_avg_sd[1]<<"\t\t"<<link_u<<"\t\t"<<KOUQ_drop_prob<<endl;
	myfile.close();

}

void islip(){

    ofstream myfile;
  	myfile.open (outfile+".txt");
  	vector<int> grantPhase(N);
    vector<int> acceptPhase(N);
    double link_u=0;

	vector<vector<pair<int,int>>> inputbuffer( N );
    vector<vector<pair<int,int>>> scheduled( N );
    vector<vector<pair<int,int>>> outputbuffer( N );
    vector<int> inputNum;

  

	for (int i = 0; i < T; ++i)
	{
		for (int j = 0; j < N; ++j)
		{
			if (outputbuffer[j].size() > 0)
			{
				//cout << outputbuffer[j][0].first << "  " << i << endl;
				int curr_delay=i- outputbuffer[j][0].first;
				delay.push_back(curr_delay);
				link_u++;
			    outputbuffer[j].clear();
			}				 				
		}

		for (int j = 0; j < N; ++j)
		{
			if (scheduled[j].size() > 0)
			{
				outputbuffer[j].push_back(make_pair(scheduled[j][0].first, scheduled[j][0].second));

			    scheduled[j].clear();
			}				 				
		}

		vector<vector<pair<int,int>>> requestPhase( N );
		requestPhase = inputbuffer;

		acceptPhase.assign(N,-1);

		while (true){
			// cin >> in;

			// cout << endl << endl << "requestPhase" << endl;

			int r = 0;
			// cout << endl << endl ;
			// for (r = 0; r < N; ++r)
			// {
			// 	cout << "row "  << r << endl;
			// 	for (int s = 0; s < requestPhase[r].size(); ++s)
			// 	{
			// 		cout << requestPhase[r][s].first  <<  "   " << r << "   "  << requestPhase[r][s].second << endl;
			// 	}
			// }


			// cout << endl << endl << "grantPhase" << endl;

			grantPhase.assign(N,-1);
			int addNum = 0;
			for (int j = 0; j < N; ++j)   // j for output port
			{
				for (int k = 0; k < N; ++k)   // k for input port
				{
					if (grantPhase[j]!= -1)
					{
						break;
					}
					if (requestPhase[(addNum +k )% N].size() > 0)
					{
						for(int l= 0;l <requestPhase[(addNum +k )% N].size();l++){
							//cout << requestPhase[(addNum +k )% N][l].second << "   "  << j << endl;
							if (requestPhase[(addNum +k )% N][l].second == j)
							{
								grantPhase[j] = (addNum +k )% N;
								addNum = grantPhase[j] +1;
								// cout << j << "   "  << grantPhase[j] << endl;
								break;
							}
						}
					}
					
				}
			}

			// cout << endl << endl << "acceptPhase" << endl;

			for (int j = 0; j < N; ++j)   // j for input port
			{
				for (int k = 0; k < N; ++k)   // k for output port
				{
					if (acceptPhase[j] != -1)
					{
						break;
					}
					if (grantPhase[k] == j)
					{
						acceptPhase[j] = k;
						// cout << j << "   "<< acceptPhase[j] << endl;
						requestPhase[j].clear(); 

						vector<pair<int,int>>::iterator it; 

						for (int q = 0; q < N; ++q)   // q for input port
						{
							if (requestPhase[q].size() > 0)
							{
								for(int l= 0;l <requestPhase[q].size();l++){
									if (requestPhase[q][l].second == k)
									{
										it = requestPhase[q].begin() + l; 
					    				requestPhase[q].erase(it);
									}
								}
							}
							
						}

						if (inputbuffer[j].size() > 0)
						{
							for(int l= 0;l <inputbuffer[j].size();l++){
								if (inputbuffer[j][l].second == k)
								{
									scheduled[k].push_back( make_pair(inputbuffer[j][l].first,j));
									it = inputbuffer[j].begin() + l; 
				    				inputbuffer[j].erase(it);
									break;
								}
							}
						}
					}
				}
				
			}
			
			for (r = 0; r < N; ++r)
			{
				if (requestPhase[r].size() > 0)
				{
					break;
				}
			}
			if (r == N)
			{
				break;
			}

		}
	
		//cout << "Time  " << i << endl;
		for (int j = 0; j < N; ++j)
		{
			const int range_from  = 0;
			const int range_to    = 999;
			std::random_device                  rand_dev;  //Will be used to obtain a seed for the random number engine
			std::mt19937                        generator(rand_dev());  //Standard mersenne_twister_engine seeded with rand_dev()
			std::uniform_int_distribution<int>  distr(range_from, range_to);   

			if(distr(generator) < range_to*p && inputbuffer[j].size() < B) {
				const int range_from  = 0;
				const int range_to    = N-1;
				std::random_device                  r_d;  //Will be used to obtain a seed for the random number engine
				std::mt19937                        gen(r_d());  //Standard mersenne_twister_engine seeded with rand_dev()
				std::uniform_int_distribution<int>  dis(range_from, range_to);    

				inputbuffer[j].push_back( make_pair(i,dis(gen)));     //Use dis to transform the random unsigned int generated by gen into an int in [range_from, range_to]
			}
		}
		
	}


	calculate_mean_sd();
	link_u=(link_u/T)/(N*N);
	//cout<<"Link Util :"<<link_u<<endl;

	cout<<"N"<<"\t\t"<<"p"<<"\t\t"<<"Queue Type"<<"\t"<<"Average PD"<<"\t"<<"Std Dev of PD"<<"\t"<<"Average Link Utilisation"<<endl;
	cout<<N<<"\t\t"<<p<<"\t\t"<<"iSLIP"<<"\t\t"<<output_avg_sd[0]<<"\t\t"<<output_avg_sd[1]<<"\t\t"<<link_u<<endl;

	myfile<<"N"<<"\t\t"<<"p"<<"\t\t"<<"Queue Type"<<"\t"<<"Average PD"<<"\t"<<"Std Dev of PD"<<"\t"<<"Average Link Utilisation"<<endl;
	myfile<<N<<"\t\t"<<p<<"\t\t"<<"iSLIP"<<"\t\t"<<output_avg_sd[0]<<"\t\t"<<output_avg_sd[1]<<"\t\t"<<link_u<<endl;
	myfile.close();

}



int main(int argc, char** argv) 
{ 
	const char* queue = "INQ";

    for (int i = 0; i < argc; ++i) {
    	if (strcmp("-N",argv[i])==0)
    	{
    		cout << argv[i++] << argv[i] << endl;
    		N = atoi(argv[i]);
    		K = 0.6 * N;
    	} else if (strcmp("-B",argv[i])==0)
    	{
    		cout << argv[i++] << argv[i] << endl;
    		B = atoi(argv[i]);
    	} else if (strcmp("-p",argv[i])==0)
    	{
    		cout << argv[i++] << argv[i] << endl;
    		p = atof(argv[i]);
    	} else if (strcmp("-queue",argv[i])==0)
    	{
    		cout << argv[i++] << argv[i] << endl;
    		queue = argv[i];
    	} else if (strcmp("-K",argv[i])==0)
    	{
    		cout << argv[i++] << argv[i] << endl;
    		K = atof(argv[i]);
    		K=K*N*N;
    	} else if (strcmp("-out",argv[i])==0)
    	{
    		cout << argv[i++] << argv[i] << endl;
    		outfile=argv[i++];
    	} else if (strcmp("-T",argv[i])==0)
    	{
    		cout << argv[i++] << argv[i] << endl;
    		T = atoi(argv[i]);
    	}
    }
    // ./routing -N 8 -B 4 -p 0.5 -queue INQ -K 4.8 -out outputfile -T 10000

    cout << endl << endl;

    if (strcmp("INQ", queue)==0)
    {
	    
	    inq();
	}

	if (strcmp("KOUQ", queue)==0)
    {
    	kouq();
	    
	}

	if (strcmp("iSLIP", queue)==0)
    {
    	islip();
	    
	}

    return 0; 
} 

