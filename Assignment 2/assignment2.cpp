#include <bits/stdc++.h>

using namespace std;

int main(int argc, char** argv) 
{ 
	int in;
	int N = 8;
	int B = 4;
	double p = 0.5;
	int T = 10000;
	double K = 0.6 * N;
	const char* queue = "INQ";
  
    for (int i = 0; i < argc; ++i) {
    	if (strcmp("-N",argv[i])==0)
    	{
    		cout << argv[i++] << argv[i] << endl;
    		N = atoi(argv[i]);
    	} else if (strcmp("-B",argv[i])==0)
    	{
    		cout << argv[i++] << argv[i] << endl;
    		B = atoi(argv[i]);
    	} else if (strcmp("-p",argv[i])==0)
    	{
    		cout << argv[i++] << argv[i] << endl;
    		p = atof(argv[i]);
    	} else if (strcmp("-queue",argv[i])==0)
    	{
    		cout << argv[i++] << argv[i] << endl;
    		queue = argv[i];
    	} else if (strcmp("-K",argv[i])==0)
    	{
    		cout << argv[i++] << argv[i] << endl;
    		K = atof(argv[i]);
    	} else if (strcmp("-out",argv[i])==0)
    	{
    		cout << argv[i++] << argv[i] << endl;
    	} else if (strcmp("-T",argv[i])==0)
    	{
    		cout << argv[i++] << argv[i] << endl;
    		T = atoi(argv[i]);
    	}
    }
    // ./routing -N 8 -B 4 -p 0.5 -queue INQ -K 4.8 -out outputfile -T 10000

    cout << endl << endl;

    if (strcmp("INQ", queue)==0)
    {
	    
	    vector<vector<pair<int,int>>> inputbuffer( N );

	    vector<int> inputNum;

		for (int i = 0; i < T; ++i)
		{
			for (int j = 0; j < N; ++j)
			{
				inputNum.clear();
				for (int k = 0; k < N; ++k)
				{
					if(inputbuffer[k].size() > 0 && inputbuffer[k][0].second == j){
						inputNum.push_back(k);
					}
				}
				if (inputNum.size() > 0)
				{
					    int range_from  = 0;
						int range_to    = inputNum.size()-1;
						std::random_device                  rand_dev;  //Will be used to obtain a seed for the random number engine
						std::mt19937                        generator(rand_dev());  //Standard mersenne_twister_engine seeded with rand_dev()
						std::uniform_int_distribution<int>  distr(range_from, range_to);   
						int num = distr(generator);
						cout << inputbuffer[inputNum[num]][0].first << "  " << i << endl;

						vector<pair<int,int>>::iterator it; 

					    it = inputbuffer[inputNum[num]].begin(); 
					    inputbuffer[inputNum[num]].erase(it); 
				}
				inputNum.clear();
			}

			for (int j = 0; j < N; ++j)
			{
				const int range_from  = 0;
				const int range_to    = 999;
				std::random_device                  rand_dev;  //Will be used to obtain a seed for the random number engine
				std::mt19937                        generator(rand_dev());  //Standard mersenne_twister_engine seeded with rand_dev()
				std::uniform_int_distribution<int>  distr(range_from, range_to);   

				if(distr(generator) < range_to*p && inputbuffer[j].size() < B) {
					const int range_from  = 0;
					const int range_to    = N-1;
					std::random_device                  r_d;  //Will be used to obtain a seed for the random number engine
					std::mt19937                        gen(r_d());  //Standard mersenne_twister_engine seeded with rand_dev()
					std::uniform_int_distribution<int>  dis(range_from, range_to);    

					inputbuffer[j].push_back( make_pair(i,dis(gen)));     //Use dis to transform the random unsigned int generated by gen into an int in [range_from, range_to]
				}
			}
		}
	}

	if (strcmp("KONQ", queue)==0)
    {
	    
	    vector<vector<int>> outputbuffer(N);

	    vector<pair<int,int>> inputNumber;

		for (int i = 0; i < T; ++i)
		{
			for (int j = 0; j < N; ++j)
			{
				if (outputbuffer[j].size() > 0)
				{
					cout << outputbuffer[j][0] << "  " << i << endl;

					vector<int>::iterator it; 

				    it = outputbuffer[j].begin(); 
				    outputbuffer[j].erase(it);
				}
				 
				
			}

			for (int j = 0; j < N; ++j)
			{
				const int range_from  = 0;
				const int range_to    = 10000;
				std::random_device                  r_d;  //Will be used to obtain a seed for the random number engine
				std::mt19937                        gen(r_d());  //Standard mersenne_twister_engine seeded with rand_dev()
				std::uniform_int_distribution<int>  dis(range_from, range_to);   

				if(dis(gen) < range_to*p) {
					const int range_from  = 0;
					const int range_to    = N-1;
					std::random_device                  rand_dev;  //Will be used to obtain a seed for the random number engine
					std::mt19937                        generator(rand_dev());  //Standard mersenne_twister_engine seeded with rand_dev()
					std::uniform_int_distribution<int>  distr(range_from, range_to);   

					inputNumber.push_back( make_pair(dis(gen),distr(generator)));     //Use dis to transform the random unsigned int generated by gen into an int in [range_from, range_to]
				}								
			}

			sort(inputNumber.begin(),inputNumber.end());

			vector<int> numOut(N,0);

			for (int j = 0; j < inputNumber.size(); ++j)
			{
				if (numOut[inputNumber[j].second]<K && outputbuffer[inputNumber[j].second].size()<B)
				{
					outputbuffer[inputNumber[j].second].push_back(i);
					numOut[inputNumber[j].second]++;
				}				
			}
			inputNumber.clear();
		}
	}

	if (strcmp("iSLIP", queue)==0)
    {
	    
	    vector<vector<int>> outputbuffer(N);

	    vector<vector<pair<int,int>>> inputbuffer( N );

	    vector<int> inputNum;

	    vector<int> grantPhase(N);
	    vector<int> acceptPhase(N);

		for (int i = 0; i < T; ++i)
		{
		
			//cout << "Time  " << i << endl;
			for (int j = 0; j < N; ++j)
			{
				const int range_from  = 0;
				const int range_to    = 999;
				std::random_device                  rand_dev;  //Will be used to obtain a seed for the random number engine
				std::mt19937                        generator(rand_dev());  //Standard mersenne_twister_engine seeded with rand_dev()
				std::uniform_int_distribution<int>  distr(range_from, range_to);   

				if(distr(generator) < range_to*p && inputbuffer[j].size() < B) {
					const int range_from  = 0;
					const int range_to    = N-1;
					std::random_device                  r_d;  //Will be used to obtain a seed for the random number engine
					std::mt19937                        gen(r_d());  //Standard mersenne_twister_engine seeded with rand_dev()
					std::uniform_int_distribution<int>  dis(range_from, range_to);    

					inputbuffer[j].push_back( make_pair(i,dis(gen)));     //Use dis to transform the random unsigned int generated by gen into an int in [range_from, range_to]
				}
			}

			vector<vector<pair<int,int>>> requestPhase( N );
			requestPhase = inputbuffer;

			acceptPhase.assign(N,-1);

			while (true){
				// cin >> in;

				// cout << endl << endl << "requestPhase" << endl;

				int r = 0;
				// cout << endl << endl ;
				// for (r = 0; r < N; ++r)
				// {
				// 	cout << "row "  << r << endl;
				// 	for (int s = 0; s < requestPhase[r].size(); ++s)
				// 	{
				// 		cout << requestPhase[r][s].first  <<  "   " << r << "   "  << requestPhase[r][s].second << endl;
				// 	}
				// }


				// cout << endl << endl << "grantPhase" << endl;

				grantPhase.assign(N,-1);
				int addNum = 0;
				for (int j = 0; j < N; ++j)   // j for output port
				{
					for (int k = 0; k < N; ++k)   // k for input port
					{
						if (grantPhase[j]!= -1)
						{
							break;
						}
						if (requestPhase[(addNum +k )% N].size() > 0)
						{
							for(int l= 0;l <requestPhase[(addNum +k )% N].size();l++){
								//cout << requestPhase[(addNum +k )% N][l].second << "   "  << j << endl;
								if (requestPhase[(addNum +k )% N][l].second == j)
								{
									grantPhase[j] = (addNum +k )% N;
									addNum = grantPhase[j] +1;
									// cout << j << "   "  << grantPhase[j] << endl;
									break;
								}
							}
						}
						
					}
				}

				// cout << endl << endl << "acceptPhase" << endl;

				for (int j = 0; j < N; ++j)   // j for input port
				{
					for (int k = 0; k < N; ++k)   // k for output port
					{
						if (acceptPhase[j] != -1)
						{
							break;
						}
						if (grantPhase[k] == j)
						{
							acceptPhase[j] = k;
							// cout << j << "   "<< acceptPhase[j] << endl;
							requestPhase[j].clear(); 

							vector<pair<int,int>>::iterator it; 

							for (int q = 0; q < N; ++q)   // q for input port
							{
								if (requestPhase[q].size() > 0)
								{
									for(int l= 0;l <requestPhase[q].size();l++){
										if (requestPhase[q][l].second == k)
										{
											it = requestPhase[q].begin() + l; 
						    				requestPhase[q].erase(it);
										}
									}
								}
								
							}

							if (inputbuffer[j].size() > 0)
							{
								for(int l= 0;l <inputbuffer[j].size();l++){
									if (inputbuffer[j][l].second == k)
									{
										it = inputbuffer[j].begin() + l; 
					    				inputbuffer[j].erase(it);
										break;
									}
								}
							}
						}
					}
					
				}
				
				for (r = 0; r < N; ++r)
				{
					if (requestPhase[r].size() > 0)
					{
						break;
					}
				}
				if (r == N)
				{
					break;
				}



			}

				

			
		}
	}


    return 0; 
} 

